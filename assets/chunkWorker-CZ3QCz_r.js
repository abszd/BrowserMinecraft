(function(){"use strict";class z{constructor(){this.chunks=new Map,this.blockTable=null,this.worldSeed=69420,this._globalPerm=null,this.TRANSPARENT_BLOCKS=new Set([-1,4,5])}initialize(e){this.worldSeed=e.worldSeed,this.blockTable=e.blockTable,this.amplitude=e.amplitude,this.chunkSize=e.chunkSize,this.chunkHeight=e.chunkHeight,this.TRANSPARENT_BLOCKS=new Set(e.transparentBlocks)}generateChunk(e,s){const t=new M(this,e,s);t.generateTerrain(),t.createTrees(),t.buildLakes();const i=`${e},${s}`;return this.chunks.set(i,t),{chunkId:i,chunkX:e,chunkZ:s,grid:Array.from(t.grid.entries()),waterBlocks:t.waterBlocks,size:t.size,height:t.height,lastAccessed:t.lastAccessed}}updateBlock(e,s,t,i,o,c=!1){const n=this.chunks.get(e);return n?(n.setBlock(s,t,i,o),c&&n.buildLakes(),{chunkId:e,grid:Array.from(n.grid.entries()),waterBlocks:n.waterBlocks,lastAccessed:n.lastAccessed}):null}getBlock(e,s,t,i){const o=this.chunks.get(e);return o?o.getBlock(s,t,i):-1}findSpawnLocation(e,s=2){const t=this.chunks.get(e);return t?t.findSpawnLocation(s):null}unloadChunk(e){this.chunks.delete(e)}generatePermTable(e){const s=new Array(512);let t=e;const i=()=>(t=(t*1664525+1013904223)%4294967296,t/4294967296);for(let o=0;o<256;o++)s[o]=Math.floor(i()*256),s[o+256]=s[o];return s}}class M{constructor(e,s,t){this.worker=e,this.chunkX=s,this.chunkZ=t,this.size=e.chunkSize,this.height=e.chunkHeight,this.grid=new Map,this.waterBlocks=[],this.lastAccessed=Date.now(),this.waterLevel=10}generateTerrain(){for(let e=0;e<this.size;e++)for(let s=0;s<this.size;s++){const t=e+this.chunkX*this.size,i=s+this.chunkZ*this.size,o=this.generateHeightAt(t,i);for(let c=0;c<o;c++){let n;c<o-4?n=1:c<o-1?n=0:n=2,this.setBlock(e,c,s,n)}}}generateHeightAt(e,s){const t=this.worker.amplitude||32,i=3,o=.005;let c=0,n=o,r=0,h=1,l=.5;for(let k=0;k<i;k++){const d=e*n,g=s*n,p=this.perlin2d(d,g);c+=p*h,r+=h,n*=2,h*=l}n=.02,h=1,r=0;for(let k=0;k<i;k++){const d=e*n,g=s*n,p=this.perlin2d(d,g);c+=p*h,r+=h,n*=2,h*=l}c/=r;let a=(c+1)*t/2;return a=Math.pow(a/t,1.2)*t,a=t/(1+Math.exp(-10*(a/t-.5))),Math.floor(Math.max(0,Math.min(t,a)))+4}perlin2d(e,s){this.worker._globalPerm||(this.worker._globalPerm=this.worker.generatePermTable(this.worker.worldSeed)),this._perm=this.worker._globalPerm;const t=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]],i=(u,B,b)=>{const m=t[u&7];return m[0]*B+m[1]*b},o=u=>u*u*u*(u*(u*6-15)+10),c=(u,B,b)=>u+b*(B-u),n=Math.floor(e)&255,r=Math.floor(s)&255,h=e-Math.floor(e),l=s-Math.floor(s),a=o(h),k=o(l),d=this._perm[n]+r,g=this._perm[n+1]+r,p=this._perm[d],A=this._perm[d+1],S=this._perm[g],T=this._perm[g+1],_=i(this._perm[p],h,l),y=i(this._perm[S],h-1,l),L=i(this._perm[A],h,l-1),$=i(this._perm[T],h-1,l-1),C=c(_,y,a),I=c(L,$,a);return c(C,I,k)}createTrees(){for(let s=2;s<this.size-2;s++)for(let t=2;t<this.size-2;t++){const i=this.getHighestBlock(s,t);if(i===-1||i<=this.waterLevel)continue;this.getBlock(s,i,t)===2&&Math.random()<.01&&this.buildTree(s,i,t)}}buildTree(e,s,t){const i=5+Math.floor(Math.random()*4);for(let n=1;n<=i&&!(s+n>=this.height);n++)this.setBlock(e,s+n,t,3);const o=Math.max(3,i-3),c=i+1;for(let n=o;n<=c;n++){let r=2;n===c&&(r=1);for(let h=-r;h<=r;h++)for(let l=-r;l<=r;l++){if(Math.abs(h)===2&&Math.abs(l)===2||h===0&&l===0&&n!==c)continue;const a=e+h,k=t+l;a>=0&&a<this.size&&k>=0&&k<this.size&&s+n<this.height&&this.getBlock(a,s+n,k)===-1&&this.setBlock(a,s+n,k,4)}}}buildLakes(){this.waterBlocks=[];for(let e=0;e<this.size;e++)for(let s=0;s<this.size;s++)for(let t=0;t<this.height;t++){const i=this.getBlock(e,t,s);if(i===5){const c=this.getBlock(e,t+1,s)!==5;this.waterBlocks.push({x:e,y:t,z:s,isTopWater:c})}if(t>=3&&t<=this.waterLevel&&i===-1){this.setBlock(e,t,s,5);const o=t===this.waterLevel;this.waterBlocks.push({x:e,y:t,z:s,isTopWater:o})}}}setBlock(e,s,t,i){this.lastAccessed=Date.now();const o=`${e} ${s} ${t}`;i===-1||i===null?this.grid.delete(o):(this.grid.set(o,i),this.grid.get(`${e} ${s-1} ${t}`)===2&&this.grid.set(`${e} ${s-1} ${t}`,0))}getBlock(e,s,t){this.lastAccessed=Date.now();const i=this.grid.get(`${e} ${s} ${t}`);return i===void 0?-1:i}getHighestBlock(e,s){for(let t=this.height-1;t>=0;t--)if(this.getBlock(e,t,s)!==-1)return t;return-1}findSpawnLocation(e=2){for(let t=0;t<100;t++){const i=Math.floor(Math.random()*(this.size-2))+1,o=Math.floor(Math.random()*(this.size-2))+1,c=this.getHighestBlock(i,o);if(c===-1)continue;const n=this.getBlock(i,c,o);if(n!==-1&&!this.worker.TRANSPARENT_BLOCKS.has(n)){let r=!0;for(let h=1;h<=e;h++)if(this.getBlock(i,c+h,o)!==-1){r=!1;break}if(r)return[i+this.chunkX*this.size+.5,c+e/2,o+this.chunkZ*this.size+.5]}}return[this.chunkX*this.size+this.size/2,this.height/2,this.chunkZ*this.size+this.size/2]}}const f=new z;self.onmessage=function(w){const{type:e,chunkX:s,chunkZ:t,params:i,chunkId:o,x:c,y:n,z:r,blockType:h,objHeight:l}=w.data;try{switch(e){case"initialize":f.initialize(i),self.postMessage({type:"initialized",success:!0});break;case"generateChunk":const a=f.generateChunk(s,t);self.postMessage({type:"chunkGenerated",data:a});break;case"updateBlock":const k=f.updateBlock(o,c,n,r,h,w.data.updateWaterMesh);k&&self.postMessage({type:"chunkUpdated",data:k});break;case"getBlock":const d=f.getBlock(o,c,n,r);self.postMessage({type:"blockResult",chunkId:o,blockId:d});break;case"findSpawn":const g=f.findSpawnLocation(o,l);self.postMessage({type:"spawnFound",chunkId:o,location:g});break;case"unloadChunk":f.unloadChunk(o),self.postMessage({type:"chunkUnloaded",chunkId:o});break;default:throw new Error(`Unknown message type: ${e}`)}}catch(a){self.postMessage({type:"error",chunkId:o,error:a.message,stack:a.stack})}}})();
