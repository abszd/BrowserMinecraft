(function(){"use strict";/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const J="176";function w(A,t,s){return Math.max(t,Math.min(s,A))}class z{constructor(t=0,s=0){z.prototype.isVector2=!0,this.x=t,this.y=s}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,s){return this.x=t,this.y=s,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const s=this.x,e=this.y,i=t.elements;return this.x=i[0]*s+i[3]*e+i[6],this.y=i[1]*s+i[4]*e+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,s){return this.x=w(this.x,t.x,s.x),this.y=w(this.y,t.y,s.y),this}clampScalar(t,s){return this.x=w(this.x,t,s),this.y=w(this.y,t,s),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(w(e,t,s))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(s===0)return Math.PI/2;const e=this.dot(t)/s;return Math.acos(w(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y;return s*s+e*e}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this}rotateAround(t,s){const e=Math.cos(s),i=Math.sin(s),h=this.x-t.x,n=this.y-t.y;return this.x=h*e-n*i+t.x,this.y=h*i+n*e+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class v{constructor(t=0,s=0,e=0,i=1){this.isQuaternion=!0,this._x=t,this._y=s,this._z=e,this._w=i}static slerpFlat(t,s,e,i,h,n,r){let o=e[i+0],c=e[i+1],l=e[i+2],u=e[i+3];const y=h[n+0],a=h[n+1],x=h[n+2],m=h[n+3];if(r===0){t[s+0]=o,t[s+1]=c,t[s+2]=l,t[s+3]=u;return}if(r===1){t[s+0]=y,t[s+1]=a,t[s+2]=x,t[s+3]=m;return}if(u!==m||o!==y||c!==a||l!==x){let _=1-r;const g=o*y+c*a+l*x+u*m,S=g>=0?1:-1,f=1-g*g;if(f>Number.EPSILON){const p=Math.sqrt(f),k=Math.atan2(p,g*S);_=Math.sin(_*k)/p,r=Math.sin(r*k)/p}const M=r*S;if(o=o*_+y*M,c=c*_+a*M,l=l*_+x*M,u=u*_+m*M,_===1-r){const p=1/Math.sqrt(o*o+c*c+l*l+u*u);o*=p,c*=p,l*=p,u*=p}}t[s]=o,t[s+1]=c,t[s+2]=l,t[s+3]=u}static multiplyQuaternionsFlat(t,s,e,i,h,n){const r=e[i],o=e[i+1],c=e[i+2],l=e[i+3],u=h[n],y=h[n+1],a=h[n+2],x=h[n+3];return t[s]=r*x+l*u+o*a-c*y,t[s+1]=o*x+l*y+c*u-r*a,t[s+2]=c*x+l*a+r*y-o*u,t[s+3]=l*x-r*u-o*y-c*a,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,e,i){return this._x=t,this._y=s,this._z=e,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s=!0){const e=t._x,i=t._y,h=t._z,n=t._order,r=Math.cos,o=Math.sin,c=r(e/2),l=r(i/2),u=r(h/2),y=o(e/2),a=o(i/2),x=o(h/2);switch(n){case"XYZ":this._x=y*l*u+c*a*x,this._y=c*a*u-y*l*x,this._z=c*l*x+y*a*u,this._w=c*l*u-y*a*x;break;case"YXZ":this._x=y*l*u+c*a*x,this._y=c*a*u-y*l*x,this._z=c*l*x-y*a*u,this._w=c*l*u+y*a*x;break;case"ZXY":this._x=y*l*u-c*a*x,this._y=c*a*u+y*l*x,this._z=c*l*x+y*a*u,this._w=c*l*u-y*a*x;break;case"ZYX":this._x=y*l*u-c*a*x,this._y=c*a*u+y*l*x,this._z=c*l*x-y*a*u,this._w=c*l*u+y*a*x;break;case"YZX":this._x=y*l*u+c*a*x,this._y=c*a*u+y*l*x,this._z=c*l*x-y*a*u,this._w=c*l*u-y*a*x;break;case"XZY":this._x=y*l*u-c*a*x,this._y=c*a*u-y*l*x,this._z=c*l*x+y*a*u,this._w=c*l*u+y*a*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+n)}return s===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const e=s/2,i=Math.sin(e);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,e=s[0],i=s[4],h=s[8],n=s[1],r=s[5],o=s[9],c=s[2],l=s[6],u=s[10],y=e+r+u;if(y>0){const a=.5/Math.sqrt(y+1);this._w=.25/a,this._x=(l-o)*a,this._y=(h-c)*a,this._z=(n-i)*a}else if(e>r&&e>u){const a=2*Math.sqrt(1+e-r-u);this._w=(l-o)/a,this._x=.25*a,this._y=(i+n)/a,this._z=(h+c)/a}else if(r>u){const a=2*Math.sqrt(1+r-e-u);this._w=(h-c)/a,this._x=(i+n)/a,this._y=.25*a,this._z=(o+l)/a}else{const a=2*Math.sqrt(1+u-e-r);this._w=(n-i)/a,this._x=(h+c)/a,this._y=(o+l)/a,this._z=.25*a}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let e=t.dot(s)+1;return e<Number.EPSILON?(e=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=e):(this._x=0,this._y=-t.z,this._z=t.y,this._w=e)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=e),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(w(this.dot(t),-1,1)))}rotateTowards(t,s){const e=this.angleTo(t);if(e===0)return this;const i=Math.min(1,s/e);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const e=t._x,i=t._y,h=t._z,n=t._w,r=s._x,o=s._y,c=s._z,l=s._w;return this._x=e*l+n*r+i*c-h*o,this._y=i*l+n*o+h*r-e*c,this._z=h*l+n*c+e*o-i*r,this._w=n*l-e*r-i*o-h*c,this._onChangeCallback(),this}slerp(t,s){if(s===0)return this;if(s===1)return this.copy(t);const e=this._x,i=this._y,h=this._z,n=this._w;let r=n*t._w+e*t._x+i*t._y+h*t._z;if(r<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,r=-r):this.copy(t),r>=1)return this._w=n,this._x=e,this._y=i,this._z=h,this;const o=1-r*r;if(o<=Number.EPSILON){const a=1-s;return this._w=a*n+s*this._w,this._x=a*e+s*this._x,this._y=a*i+s*this._y,this._z=a*h+s*this._z,this.normalize(),this}const c=Math.sqrt(o),l=Math.atan2(c,r),u=Math.sin((1-s)*l)/c,y=Math.sin(s*l)/c;return this._w=n*u+this._w*y,this._x=e*u+this._x*y,this._y=i*u+this._y*y,this._z=h*u+this._z*y,this._onChangeCallback(),this}slerpQuaternions(t,s,e){return this.copy(t).slerp(s,e)}random(){const t=2*Math.PI*Math.random(),s=2*Math.PI*Math.random(),e=Math.random(),i=Math.sqrt(1-e),h=Math.sqrt(e);return this.set(i*Math.sin(t),i*Math.cos(t),h*Math.sin(s),h*Math.cos(s))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class b{constructor(t=0,s=0,e=0){b.prototype.isVector3=!0,this.x=t,this.y=s,this.z=e}set(t,s,e){return e===void 0&&(e=this.z),this.x=t,this.y=s,this.z=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return this.applyQuaternion(K.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(K.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,e=this.y,i=this.z,h=t.elements;return this.x=h[0]*s+h[3]*e+h[6]*i,this.y=h[1]*s+h[4]*e+h[7]*i,this.z=h[2]*s+h[5]*e+h[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,e=this.y,i=this.z,h=t.elements,n=1/(h[3]*s+h[7]*e+h[11]*i+h[15]);return this.x=(h[0]*s+h[4]*e+h[8]*i+h[12])*n,this.y=(h[1]*s+h[5]*e+h[9]*i+h[13])*n,this.z=(h[2]*s+h[6]*e+h[10]*i+h[14])*n,this}applyQuaternion(t){const s=this.x,e=this.y,i=this.z,h=t.x,n=t.y,r=t.z,o=t.w,c=2*(n*i-r*e),l=2*(r*s-h*i),u=2*(h*e-n*s);return this.x=s+o*c+n*u-r*l,this.y=e+o*l+r*c-h*u,this.z=i+o*u+h*l-n*c,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,e=this.y,i=this.z,h=t.elements;return this.x=h[0]*s+h[4]*e+h[8]*i,this.y=h[1]*s+h[5]*e+h[9]*i,this.z=h[2]*s+h[6]*e+h[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=w(this.x,t.x,s.x),this.y=w(this.y,t.y,s.y),this.z=w(this.z,t.z,s.z),this}clampScalar(t,s){return this.x=w(this.x,t,s),this.y=w(this.y,t,s),this.z=w(this.z,t,s),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(w(e,t,s))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this.z=t.z+(s.z-t.z)*e,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,s){const e=t.x,i=t.y,h=t.z,n=s.x,r=s.y,o=s.z;return this.x=i*o-h*r,this.y=h*n-e*o,this.z=e*r-i*n,this}projectOnVector(t){const s=t.lengthSq();if(s===0)return this.set(0,0,0);const e=t.dot(this)/s;return this.copy(t).multiplyScalar(e)}projectOnPlane(t){return j.copy(this).projectOnVector(t),this.sub(j)}reflect(t){return this.sub(j.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(s===0)return Math.PI/2;const e=this.dot(t)/s;return Math.acos(w(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return s*s+e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,e){const i=Math.sin(s)*t;return this.x=i*Math.sin(e),this.y=Math.cos(s)*t,this.z=i*Math.cos(e),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,e){return this.x=t*Math.sin(s),this.y=e,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=e,this.z=i,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,s*4)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,s*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,s=Math.random()*2-1,e=Math.sqrt(1-s*s);return this.x=e*Math.cos(t),this.y=s,this.z=e*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const j=new b,K=new v;class I{constructor(t,s,e,i,h,n,r,o,c,l,u,y,a,x,m,_){I.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,s,e,i,h,n,r,o,c,l,u,y,a,x,m,_)}set(t,s,e,i,h,n,r,o,c,l,u,y,a,x,m,_){const g=this.elements;return g[0]=t,g[4]=s,g[8]=e,g[12]=i,g[1]=h,g[5]=n,g[9]=r,g[13]=o,g[2]=c,g[6]=l,g[10]=u,g[14]=y,g[3]=a,g[7]=x,g[11]=m,g[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new I().fromArray(this.elements)}copy(t){const s=this.elements,e=t.elements;return s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],s[4]=e[4],s[5]=e[5],s[6]=e[6],s[7]=e[7],s[8]=e[8],s[9]=e[9],s[10]=e[10],s[11]=e[11],s[12]=e[12],s[13]=e[13],s[14]=e[14],s[15]=e[15],this}copyPosition(t){const s=this.elements,e=t.elements;return s[12]=e[12],s[13]=e[13],s[14]=e[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,e){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(t,s,e){return this.set(t.x,s.x,e.x,0,t.y,s.y,e.y,0,t.z,s.z,e.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,e=t.elements,i=1/N.setFromMatrixColumn(t,0).length(),h=1/N.setFromMatrixColumn(t,1).length(),n=1/N.setFromMatrixColumn(t,2).length();return s[0]=e[0]*i,s[1]=e[1]*i,s[2]=e[2]*i,s[3]=0,s[4]=e[4]*h,s[5]=e[5]*h,s[6]=e[6]*h,s[7]=0,s[8]=e[8]*n,s[9]=e[9]*n,s[10]=e[10]*n,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){const s=this.elements,e=t.x,i=t.y,h=t.z,n=Math.cos(e),r=Math.sin(e),o=Math.cos(i),c=Math.sin(i),l=Math.cos(h),u=Math.sin(h);if(t.order==="XYZ"){const y=n*l,a=n*u,x=r*l,m=r*u;s[0]=o*l,s[4]=-o*u,s[8]=c,s[1]=a+x*c,s[5]=y-m*c,s[9]=-r*o,s[2]=m-y*c,s[6]=x+a*c,s[10]=n*o}else if(t.order==="YXZ"){const y=o*l,a=o*u,x=c*l,m=c*u;s[0]=y+m*r,s[4]=x*r-a,s[8]=n*c,s[1]=n*u,s[5]=n*l,s[9]=-r,s[2]=a*r-x,s[6]=m+y*r,s[10]=n*o}else if(t.order==="ZXY"){const y=o*l,a=o*u,x=c*l,m=c*u;s[0]=y-m*r,s[4]=-n*u,s[8]=x+a*r,s[1]=a+x*r,s[5]=n*l,s[9]=m-y*r,s[2]=-n*c,s[6]=r,s[10]=n*o}else if(t.order==="ZYX"){const y=n*l,a=n*u,x=r*l,m=r*u;s[0]=o*l,s[4]=x*c-a,s[8]=y*c+m,s[1]=o*u,s[5]=m*c+y,s[9]=a*c-x,s[2]=-c,s[6]=r*o,s[10]=n*o}else if(t.order==="YZX"){const y=n*o,a=n*c,x=r*o,m=r*c;s[0]=o*l,s[4]=m-y*u,s[8]=x*u+a,s[1]=u,s[5]=n*l,s[9]=-r*l,s[2]=-c*l,s[6]=a*u+x,s[10]=y-m*u}else if(t.order==="XZY"){const y=n*o,a=n*c,x=r*o,m=r*c;s[0]=o*l,s[4]=-u,s[8]=c*l,s[1]=y*u+m,s[5]=n*l,s[9]=a*u-x,s[2]=x*u-a,s[6]=r*l,s[10]=m*u+y}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(tt,t,st)}lookAt(t,s,e){const i=this.elements;return L.subVectors(t,s),L.lengthSq()===0&&(L.z=1),L.normalize(),B.crossVectors(e,L),B.lengthSq()===0&&(Math.abs(e.z)===1?L.x+=1e-4:L.z+=1e-4,L.normalize(),B.crossVectors(e,L)),B.normalize(),$.crossVectors(L,B),i[0]=B.x,i[4]=$.x,i[8]=L.x,i[1]=B.y,i[5]=$.y,i[9]=L.y,i[2]=B.z,i[6]=$.z,i[10]=L.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const e=t.elements,i=s.elements,h=this.elements,n=e[0],r=e[4],o=e[8],c=e[12],l=e[1],u=e[5],y=e[9],a=e[13],x=e[2],m=e[6],_=e[10],g=e[14],S=e[3],f=e[7],M=e[11],p=e[15],k=i[0],d=i[4],V=i[8],C=i[12],P=i[1],E=i[5],q=i[9],X=i[13],Z=i[2],H=i[6],Y=i[10],D=i[14],W=i[3],U=i[7],Q=i[11],G=i[15];return h[0]=n*k+r*P+o*Z+c*W,h[4]=n*d+r*E+o*H+c*U,h[8]=n*V+r*q+o*Y+c*Q,h[12]=n*C+r*X+o*D+c*G,h[1]=l*k+u*P+y*Z+a*W,h[5]=l*d+u*E+y*H+a*U,h[9]=l*V+u*q+y*Y+a*Q,h[13]=l*C+u*X+y*D+a*G,h[2]=x*k+m*P+_*Z+g*W,h[6]=x*d+m*E+_*H+g*U,h[10]=x*V+m*q+_*Y+g*Q,h[14]=x*C+m*X+_*D+g*G,h[3]=S*k+f*P+M*Z+p*W,h[7]=S*d+f*E+M*H+p*U,h[11]=S*V+f*q+M*Y+p*Q,h[15]=S*C+f*X+M*D+p*G,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],e=t[4],i=t[8],h=t[12],n=t[1],r=t[5],o=t[9],c=t[13],l=t[2],u=t[6],y=t[10],a=t[14],x=t[3],m=t[7],_=t[11],g=t[15];return x*(+h*o*u-i*c*u-h*r*y+e*c*y+i*r*a-e*o*a)+m*(+s*o*a-s*c*y+h*n*y-i*n*a+i*c*l-h*o*l)+_*(+s*c*u-s*r*a-h*n*u+e*n*a+h*r*l-e*c*l)+g*(-i*r*l-s*o*u+s*r*y+i*n*u-e*n*y+e*o*l)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,e){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=s,i[14]=e),this}invert(){const t=this.elements,s=t[0],e=t[1],i=t[2],h=t[3],n=t[4],r=t[5],o=t[6],c=t[7],l=t[8],u=t[9],y=t[10],a=t[11],x=t[12],m=t[13],_=t[14],g=t[15],S=u*_*c-m*y*c+m*o*a-r*_*a-u*o*g+r*y*g,f=x*y*c-l*_*c-x*o*a+n*_*a+l*o*g-n*y*g,M=l*m*c-x*u*c+x*r*a-n*m*a-l*r*g+n*u*g,p=x*u*o-l*m*o-x*r*y+n*m*y+l*r*_-n*u*_,k=s*S+e*f+i*M+h*p;if(k===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const d=1/k;return t[0]=S*d,t[1]=(m*y*h-u*_*h-m*i*a+e*_*a+u*i*g-e*y*g)*d,t[2]=(r*_*h-m*o*h+m*i*c-e*_*c-r*i*g+e*o*g)*d,t[3]=(u*o*h-r*y*h-u*i*c+e*y*c+r*i*a-e*o*a)*d,t[4]=f*d,t[5]=(l*_*h-x*y*h+x*i*a-s*_*a-l*i*g+s*y*g)*d,t[6]=(x*o*h-n*_*h-x*i*c+s*_*c+n*i*g-s*o*g)*d,t[7]=(n*y*h-l*o*h+l*i*c-s*y*c-n*i*a+s*o*a)*d,t[8]=M*d,t[9]=(x*u*h-l*m*h-x*e*a+s*m*a+l*e*g-s*u*g)*d,t[10]=(n*m*h-x*r*h+x*e*c-s*m*c-n*e*g+s*r*g)*d,t[11]=(l*r*h-n*u*h-l*e*c+s*u*c+n*e*a-s*r*a)*d,t[12]=p*d,t[13]=(l*m*i-x*u*i+x*e*y-s*m*y-l*e*_+s*u*_)*d,t[14]=(x*r*i-n*m*i-x*e*o+s*m*o+n*e*_-s*r*_)*d,t[15]=(n*u*i-l*r*i+l*e*o-s*u*o-n*e*y+s*r*y)*d,this}scale(t){const s=this.elements,e=t.x,i=t.y,h=t.z;return s[0]*=e,s[4]*=i,s[8]*=h,s[1]*=e,s[5]*=i,s[9]*=h,s[2]*=e,s[6]*=i,s[10]*=h,s[3]*=e,s[7]*=i,s[11]*=h,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,e,i))}makeTranslation(t,s,e){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,s,0,0,1,e,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,s,-e,0,0,e,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,0,e,0,0,1,0,0,-e,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,-e,0,0,e,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const e=Math.cos(s),i=Math.sin(s),h=1-e,n=t.x,r=t.y,o=t.z,c=h*n,l=h*r;return this.set(c*n+e,c*r-i*o,c*o+i*r,0,c*r+i*o,l*r+e,l*o-i*n,0,c*o-i*r,l*o+i*n,h*o*o+e,0,0,0,0,1),this}makeScale(t,s,e){return this.set(t,0,0,0,0,s,0,0,0,0,e,0,0,0,0,1),this}makeShear(t,s,e,i,h,n){return this.set(1,e,h,0,t,1,n,0,s,i,1,0,0,0,0,1),this}compose(t,s,e){const i=this.elements,h=s._x,n=s._y,r=s._z,o=s._w,c=h+h,l=n+n,u=r+r,y=h*c,a=h*l,x=h*u,m=n*l,_=n*u,g=r*u,S=o*c,f=o*l,M=o*u,p=e.x,k=e.y,d=e.z;return i[0]=(1-(m+g))*p,i[1]=(a+M)*p,i[2]=(x-f)*p,i[3]=0,i[4]=(a-M)*k,i[5]=(1-(y+g))*k,i[6]=(_+S)*k,i[7]=0,i[8]=(x+f)*d,i[9]=(_-S)*d,i[10]=(1-(y+m))*d,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,s,e){const i=this.elements;let h=N.set(i[0],i[1],i[2]).length();const n=N.set(i[4],i[5],i[6]).length(),r=N.set(i[8],i[9],i[10]).length();this.determinant()<0&&(h=-h),t.x=i[12],t.y=i[13],t.z=i[14],T.copy(this);const c=1/h,l=1/n,u=1/r;return T.elements[0]*=c,T.elements[1]*=c,T.elements[2]*=c,T.elements[4]*=l,T.elements[5]*=l,T.elements[6]*=l,T.elements[8]*=u,T.elements[9]*=u,T.elements[10]*=u,s.setFromRotationMatrix(T),e.x=h,e.y=n,e.z=r,this}makePerspective(t,s,e,i,h,n,r=2e3){const o=this.elements,c=2*h/(s-t),l=2*h/(e-i),u=(s+t)/(s-t),y=(e+i)/(e-i);let a,x;if(r===2e3)a=-(n+h)/(n-h),x=-2*n*h/(n-h);else if(r===2001)a=-n/(n-h),x=-n*h/(n-h);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+r);return o[0]=c,o[4]=0,o[8]=u,o[12]=0,o[1]=0,o[5]=l,o[9]=y,o[13]=0,o[2]=0,o[6]=0,o[10]=a,o[14]=x,o[3]=0,o[7]=0,o[11]=-1,o[15]=0,this}makeOrthographic(t,s,e,i,h,n,r=2e3){const o=this.elements,c=1/(s-t),l=1/(e-i),u=1/(n-h),y=(s+t)*c,a=(e+i)*l;let x,m;if(r===2e3)x=(n+h)*u,m=-2*u;else if(r===2001)x=h*u,m=-1*u;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+r);return o[0]=2*c,o[4]=0,o[8]=0,o[12]=-y,o[1]=0,o[5]=2*l,o[9]=0,o[13]=-a,o[2]=0,o[6]=0,o[10]=m,o[14]=-x,o[3]=0,o[7]=0,o[11]=0,o[15]=1,this}equals(t){const s=this.elements,e=t.elements;for(let i=0;i<16;i++)if(s[i]!==e[i])return!1;return!0}fromArray(t,s=0){for(let e=0;e<16;e++)this.elements[e]=t[e+s];return this}toArray(t=[],s=0){const e=this.elements;return t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3],t[s+4]=e[4],t[s+5]=e[5],t[s+6]=e[6],t[s+7]=e[7],t[s+8]=e[8],t[s+9]=e[9],t[s+10]=e[10],t[s+11]=e[11],t[s+12]=e[12],t[s+13]=e[13],t[s+14]=e[14],t[s+15]=e[15],t}}const N=new b,T=new I,tt=new b(0,0,0),st=new b(1,1,1),B=new b,$=new b,L=new b;class et{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(t,s){const e=this.getUtoTmapping(t);return this.getPoint(e,s)}getPoints(t=5){const s=[];for(let e=0;e<=t;e++)s.push(this.getPoint(e/t));return s}getSpacedPoints(t=5){const s=[];for(let e=0;e<=t;e++)s.push(this.getPointAt(e/t));return s}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const s=[];let e,i=this.getPoint(0),h=0;s.push(0);for(let n=1;n<=t;n++)e=this.getPoint(n/t),h+=e.distanceTo(i),s.push(h),i=e;return this.cacheArcLengths=s,s}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,s=null){const e=this.getLengths();let i=0;const h=e.length;let n;s?n=s:n=t*e[h-1];let r=0,o=h-1,c;for(;r<=o;)if(i=Math.floor(r+(o-r)/2),c=e[i]-n,c<0)r=i+1;else if(c>0)o=i-1;else{o=i;break}if(i=o,e[i]===n)return i/(h-1);const l=e[i],y=e[i+1]-l,a=(n-l)/y;return(i+a)/(h-1)}getTangent(t,s){let i=t-1e-4,h=t+1e-4;i<0&&(i=0),h>1&&(h=1);const n=this.getPoint(i),r=this.getPoint(h),o=s||(n.isVector2?new z:new b);return o.copy(r).sub(n).normalize(),o}getTangentAt(t,s){const e=this.getUtoTmapping(t);return this.getTangent(e,s)}computeFrenetFrames(t,s=!1){const e=new b,i=[],h=[],n=[],r=new b,o=new I;for(let a=0;a<=t;a++){const x=a/t;i[a]=this.getTangentAt(x,new b)}h[0]=new b,n[0]=new b;let c=Number.MAX_VALUE;const l=Math.abs(i[0].x),u=Math.abs(i[0].y),y=Math.abs(i[0].z);l<=c&&(c=l,e.set(1,0,0)),u<=c&&(c=u,e.set(0,1,0)),y<=c&&e.set(0,0,1),r.crossVectors(i[0],e).normalize(),h[0].crossVectors(i[0],r),n[0].crossVectors(i[0],h[0]);for(let a=1;a<=t;a++){if(h[a]=h[a-1].clone(),n[a]=n[a-1].clone(),r.crossVectors(i[a-1],i[a]),r.length()>Number.EPSILON){r.normalize();const x=Math.acos(w(i[a-1].dot(i[a]),-1,1));h[a].applyMatrix4(o.makeRotationAxis(r,x))}n[a].crossVectors(i[a],h[a])}if(s===!0){let a=Math.acos(w(h[0].dot(h[t]),-1,1));a/=t,i[0].dot(r.crossVectors(h[0],h[t]))>0&&(a=-a);for(let x=1;x<=t;x++)h[x].applyMatrix4(o.makeRotationAxis(i[x],a*x)),n[x].crossVectors(i[x],h[x])}return{tangents:i,normals:h,binormals:n}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}function O(A,t,s,e,i){const h=(e-t)*.5,n=(i-s)*.5,r=A*A,o=A*r;return(2*s-2*e+h+n)*o+(-3*s+3*e-2*h-n)*r+h*A+s}class F extends et{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,s=new z){const e=s,i=this.points,h=(i.length-1)*t,n=Math.floor(h),r=h-n,o=i[n===0?n:n-1],c=i[n],l=i[n>i.length-2?i.length-1:n+1],u=i[n>i.length-3?i.length-1:n+2];return e.set(O(r,o.x,c.x,l.x,u.x),O(r,o.y,c.y,l.y,u.y)),e}copy(t){super.copy(t),this.points=[];for(let s=0,e=t.points.length;s<e;s++){const i=t.points[s];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let s=0,e=this.points.length;s<e;s++){const i=this.points[s];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let s=0,e=t.points.length;s<e;s++){const i=t.points[s];this.points.push(new z().fromArray(i))}return this}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:J}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=J);class it{constructor(){this.chunks=new Map,this.blockTable=null,this.worldSeed=69420,this._globalPerm=null,this.continentalSpline=new F([new z(0,.01),new z(.1,.1),new z(.25,.1),new z(.5,.3),new z(.65,.4),new z(.7,.6),new z(.8,.85),new z(1,.5)])}initialize(t){this.worldSeed=t.worldSeed,this.blockTable=t.blockTable,this.amplitude=t.amplitude,this.chunkSize=t.chunkSize,this.chunkHeight=t.chunkHeight,this.TRANSPARENT_BLOCKS=new Set(t.transparentBlocks)}generateChunk(t,s){const e=new ht(this,t,s);e.generateTerrain(),e.createTrees(),e.buildLakes();const i=`${t},${s}`;return this.chunks.set(i,e),{chunkId:i,chunkX:t,chunkZ:s,grid:Array.from(e.grid.entries()),waterBlocks:e.waterBlocks,size:e.size,height:e.height,lastAccessed:e.lastAccessed}}updateBlock(t,s,e,i,h,n=!1){const r=this.chunks.get(t);return r?(r.setBlock(s,e,i,h),n&&r.buildLakes(),{chunkId:t,grid:Array.from(r.grid.entries()),waterBlocks:r.waterBlocks,lastAccessed:r.lastAccessed}):null}getBlock(t,s,e,i){const h=this.chunks.get(t);return h?h.getBlock(s,e,i):-1}findSpawnLocation(t,s=2){const e=this.chunks.get(t);return e?e.findSpawnLocation(s):null}unloadChunk(t){this.chunks.delete(t)}generatePermTable(t){const s=new Array(512);let e=t;const i=()=>(e=(e*1664525+1013904223)%4294967296,e/4294967296);for(let h=0;h<256;h++)s[h]=Math.floor(i()*256),s[h+256]=s[h];return s}}class ht{constructor(t,s,e){this.worker=t,this.chunkX=s,this.chunkZ=e,this.size=t.chunkSize,this.height=t.chunkHeight,this.grid=new Map,this.waterBlocks=[],this.lastAccessed=Date.now(),this.waterLevel=Math.floor(this.worker.amplitude/3),this.TRANSPARENT_BLOCKS=new Set([-1,4,5]),this.CSpline=new F([new z(0,0),new z(.75,.25),new z(1,1)]),this.MVSpline=new F([new z(0,.1),new z(.1,.2),new z(.2,.6),new z(.4,.2),new z(.5,1),new z(.75,.6),new z(1,.6)]),this.PVSpline=new F([new z(0,0),new z(.43,.2),new z(.8,1),new z(.83,.7),new z(1,.7)])}generateTerrain(){const t=new Map,s=2.5,e=1.5;for(let i=-1;i<=this.size;i++)for(let h=-1;h<=this.size;h++){const n=i+this.chunkX*this.size,r=h+this.chunkZ*this.size;t.set(`${i},${h}`,this.generateHeightAt(n,r))}for(let i=0;i<this.size;i++)for(let h=0;h<this.size;h++){const n=t.get(`${i},${h}`),r=t.get(`${i+1},${h}`)||n,o=t.get(`${i},${h+1}`)||n,c=t.get(`${i-1},${h}`)||n,l=t.get(`${i},${h-1}`)||n,u=(r-c)/2,y=(o-l)/2,a=(u+y)/2;for(let x=0;x<n;x++){let m;x<n-4?m=1:x-this.waterLevel<=1?m=7:x<n-1?a>e?m=1:m=0:a<e?m=2:a<s?m=0:m=1,this.setBlock(i,x,h,m)}}}generateHeightAt(t,s){let i=this.getNoise(3,.003,.5,t,s),h=this.getNoise(3,.003*2,.5,t,s),n=this.getNoise(3,.03,.5,t,s);const r=this.CSpline.getPoint(i).y,o=this.MVSpline.getPoint(h).y,c=this.PVSpline.getPoint(n).y,a=(r+o*r+c*o*r)*this.worker.amplitude;return Math.min(this.worker.chunkHeight,a)}getNoise(t,s,e,i,h){let n=0,r=s,o=0,c=1;for(let l=0;l<t;l++){const u=this.perlin2d(i*r,h*r);n+=u*c,o+=c,r*=2,c*=e}return(n/o+1)/2}perlin2d(t,s){this.worker._globalPerm||(this.worker._globalPerm=this.worker.generatePermTable(this.worker.worldSeed)),this._perm=this.worker._globalPerm;const e=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]],i=(C,P,E)=>{const q=e[C&7];return q[0]*P+q[1]*E},h=C=>C*C*C*(C*(C*6-15)+10),n=(C,P,E)=>C+E*(P-C),r=Math.floor(t)&255,o=Math.floor(s)&255,c=t-Math.floor(t),l=s-Math.floor(s),u=h(c),y=h(l),a=this._perm[r]+o,x=this._perm[r+1]+o,m=this._perm[a],_=this._perm[a+1],g=this._perm[x],S=this._perm[x+1],f=i(this._perm[m],c,l),M=i(this._perm[g],c-1,l),p=i(this._perm[_],c,l-1),k=i(this._perm[S],c-1,l-1),d=n(f,M,u),V=n(p,k,u);return n(d,V,y)}createTrees(){for(let s=2;s<this.size-2;s++)for(let e=2;e<this.size-2;e++){const i=this.getHighestBlock(s,e);if(i===-1||i<=this.waterLevel)continue;this.getBlock(s,i,e)===2&&Math.random()<.01&&this.buildTree(s,i,e)}}buildTree(t,s,e){const i=5+Math.floor(Math.random()*4);for(let r=1;r<=i&&!(s+r>=this.height);r++)this.setBlock(t,s+r,e,3);const h=Math.max(3,i-3),n=i+1;for(let r=h;r<=n;r++){let o=2;r===n&&(o=1);for(let c=-o;c<=o;c++)for(let l=-o;l<=o;l++){if(Math.abs(c)===2&&Math.abs(l)===2||c===0&&l===0&&r!==n)continue;const u=t+c,y=e+l;u>=0&&u<this.size&&y>=0&&y<this.size&&s+r<this.height&&this.getBlock(u,s+r,y)===-1&&this.setBlock(u,s+r,y,4)}}}buildLakes(){this.waterBlocks=[];for(let t=0;t<this.size;t++)for(let s=0;s<this.size;s++)for(let e=0;e<this.height;e++){const i=this.getBlock(t,e,s);if(i===5){const n=this.getBlock(t,e+1,s)!==5;this.waterBlocks.push({x:t,y:e,z:s,isTopWater:n})}if(e>=3&&e<=this.waterLevel&&i===-1){this.setBlock(t,e,s,5);const h=e===this.waterLevel;this.waterBlocks.push({x:t,y:e,z:s,isTopWater:h})}}}setBlock(t,s,e,i){this.lastAccessed=Date.now();const h=`${t} ${s} ${e}`;i===-1||i===null?this.grid.delete(h):(this.grid.set(h,i),this.grid.get(`${t} ${s-1} ${e}`)===2&&!this.TRANSPARENT_BLOCKS.has(i)&&this.grid.set(`${t} ${s-1} ${e}`,0))}getBlock(t,s,e){this.lastAccessed=Date.now();const i=this.grid.get(`${t} ${s} ${e}`);return i===void 0?-1:i}getHighestBlock(t,s){for(let e=this.height-1;e>=0;e--)if(this.getBlock(t,e,s)!==-1)return e;return-1}findSpawnLocation(t=2){for(let e=0;e<100;e++){const i=Math.floor(Math.random()*(this.size-2))+1,h=Math.floor(Math.random()*(this.size-2))+1,n=this.getHighestBlock(i,h);if(n===-1)continue;const r=this.getBlock(i,n,h);if(r!==-1&&!this.worker.TRANSPARENT_BLOCKS.has(r)){let o=!0;for(let c=1;c<=t;c++)if(this.getBlock(i,n+c,h)!==-1){o=!1;break}if(o)return[i+this.chunkX*this.size+.5,n+t/2,h+this.chunkZ*this.size+.5]}}return[this.chunkX*this.size+this.size/2,this.height/2,this.chunkZ*this.size+this.size/2]}}const R=new it;self.onmessage=function(A){const{type:t,chunkX:s,chunkZ:e,params:i,chunkId:h,x:n,y:r,z:o,blockType:c,objHeight:l}=A.data;try{switch(t){case"initialize":R.initialize(i),self.postMessage({type:"initialized",success:!0});break;case"generateChunk":const u=R.generateChunk(s,e);self.postMessage({type:"chunkGenerated",data:u});break;case"updateBlock":const y=R.updateBlock(h,n,r,o,c,A.data.updateWaterMesh);y&&self.postMessage({type:"chunkUpdated",data:y});break;case"getBlock":const a=R.getBlock(h,n,r,o);self.postMessage({type:"blockResult",chunkId:h,blockId:a});break;case"findSpawn":const x=R.findSpawnLocation(h,l);self.postMessage({type:"spawnFound",chunkId:h,location:x});break;case"unloadChunk":R.unloadChunk(h),self.postMessage({type:"chunkUnloaded",chunkId:h});break;default:throw new Error(`Unknown message type: ${t}`)}}catch(u){self.postMessage({type:"error",chunkId:h,error:u.message,stack:u.stack})}}})();
