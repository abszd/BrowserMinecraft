(function(){"use strict";/**
 * @license
 * Copyright 2010-2025 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const J="176";function w(C,t,s){return Math.max(t,Math.min(s,C))}class d{constructor(t=0,s=0){d.prototype.isVector2=!0,this.x=t,this.y=s}get width(){return this.x}set width(t){this.x=t}get height(){return this.y}set height(t){this.y=t}set(t,s){return this.x=t,this.y=s,this}setScalar(t){return this.x=t,this.y=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y)}copy(t){return this.x=t.x,this.y=t.y,this}add(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this}subScalar(t){return this.x-=t,this.y-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this}multiply(t){return this.x*=t.x,this.y*=t.y,this}multiplyScalar(t){return this.x*=t,this.y*=t,this}divide(t){return this.x/=t.x,this.y/=t.y,this}divideScalar(t){return this.multiplyScalar(1/t)}applyMatrix3(t){const s=this.x,e=this.y,i=t.elements;return this.x=i[0]*s+i[3]*e+i[6],this.y=i[1]*s+i[4]*e+i[7],this}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this}clamp(t,s){return this.x=w(this.x,t.x,s.x),this.y=w(this.y,t.y,s.y),this}clampScalar(t,s){return this.x=w(this.x,t,s),this.y=w(this.y,t,s),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(w(e,t,s))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(t){return this.x*t.x+this.y*t.y}cross(t){return this.x*t.y-this.y*t.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(s===0)return Math.PI/2;const e=this.dot(t)/s;return Math.acos(w(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y;return s*s+e*e}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this}equals(t){return t.x===this.x&&t.y===this.y}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this}rotateAround(t,s){const e=Math.cos(s),i=Math.sin(s),h=this.x-t.x,n=this.y-t.y;return this.x=h*e-n*i+t.x,this.y=h*i+n*e+t.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class v{constructor(t=0,s=0,e=0,i=1){this.isQuaternion=!0,this._x=t,this._y=s,this._z=e,this._w=i}static slerpFlat(t,s,e,i,h,n,o){let r=e[i+0],a=e[i+1],l=e[i+2],u=e[i+3];const y=h[n+0],c=h[n+1],x=h[n+2],m=h[n+3];if(o===0){t[s+0]=r,t[s+1]=a,t[s+2]=l,t[s+3]=u;return}if(o===1){t[s+0]=y,t[s+1]=c,t[s+2]=x,t[s+3]=m;return}if(u!==m||r!==y||a!==c||l!==x){let _=1-o;const g=r*y+a*c+l*x+u*m,b=g>=0?1:-1,f=1-g*g;if(f>Number.EPSILON){const p=Math.sqrt(f),k=Math.atan2(p,g*b);_=Math.sin(_*k)/p,o=Math.sin(o*k)/p}const M=o*b;if(r=r*_+y*M,a=a*_+c*M,l=l*_+x*M,u=u*_+m*M,_===1-o){const p=1/Math.sqrt(r*r+a*a+l*l+u*u);r*=p,a*=p,l*=p,u*=p}}t[s]=r,t[s+1]=a,t[s+2]=l,t[s+3]=u}static multiplyQuaternionsFlat(t,s,e,i,h,n){const o=e[i],r=e[i+1],a=e[i+2],l=e[i+3],u=h[n],y=h[n+1],c=h[n+2],x=h[n+3];return t[s]=o*x+l*u+r*c-a*y,t[s+1]=r*x+l*y+a*u-o*c,t[s+2]=a*x+l*c+o*y-r*u,t[s+3]=l*x-o*u-r*y-a*c,t}get x(){return this._x}set x(t){this._x=t,this._onChangeCallback()}get y(){return this._y}set y(t){this._y=t,this._onChangeCallback()}get z(){return this._z}set z(t){this._z=t,this._onChangeCallback()}get w(){return this._w}set w(t){this._w=t,this._onChangeCallback()}set(t,s,e,i){return this._x=t,this._y=s,this._z=e,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(t){return this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._onChangeCallback(),this}setFromEuler(t,s=!0){const e=t._x,i=t._y,h=t._z,n=t._order,o=Math.cos,r=Math.sin,a=o(e/2),l=o(i/2),u=o(h/2),y=r(e/2),c=r(i/2),x=r(h/2);switch(n){case"XYZ":this._x=y*l*u+a*c*x,this._y=a*c*u-y*l*x,this._z=a*l*x+y*c*u,this._w=a*l*u-y*c*x;break;case"YXZ":this._x=y*l*u+a*c*x,this._y=a*c*u-y*l*x,this._z=a*l*x-y*c*u,this._w=a*l*u+y*c*x;break;case"ZXY":this._x=y*l*u-a*c*x,this._y=a*c*u+y*l*x,this._z=a*l*x+y*c*u,this._w=a*l*u-y*c*x;break;case"ZYX":this._x=y*l*u-a*c*x,this._y=a*c*u+y*l*x,this._z=a*l*x-y*c*u,this._w=a*l*u+y*c*x;break;case"YZX":this._x=y*l*u+a*c*x,this._y=a*c*u+y*l*x,this._z=a*l*x-y*c*u,this._w=a*l*u-y*c*x;break;case"XZY":this._x=y*l*u-a*c*x,this._y=a*c*u-y*l*x,this._z=a*l*x+y*c*u,this._w=a*l*u+y*c*x;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+n)}return s===!0&&this._onChangeCallback(),this}setFromAxisAngle(t,s){const e=s/2,i=Math.sin(e);return this._x=t.x*i,this._y=t.y*i,this._z=t.z*i,this._w=Math.cos(e),this._onChangeCallback(),this}setFromRotationMatrix(t){const s=t.elements,e=s[0],i=s[4],h=s[8],n=s[1],o=s[5],r=s[9],a=s[2],l=s[6],u=s[10],y=e+o+u;if(y>0){const c=.5/Math.sqrt(y+1);this._w=.25/c,this._x=(l-r)*c,this._y=(h-a)*c,this._z=(n-i)*c}else if(e>o&&e>u){const c=2*Math.sqrt(1+e-o-u);this._w=(l-r)/c,this._x=.25*c,this._y=(i+n)/c,this._z=(h+a)/c}else if(o>u){const c=2*Math.sqrt(1+o-e-u);this._w=(h-a)/c,this._x=(i+n)/c,this._y=.25*c,this._z=(r+l)/c}else{const c=2*Math.sqrt(1+u-e-o);this._w=(n-i)/c,this._x=(h+a)/c,this._y=(r+l)/c,this._z=.25*c}return this._onChangeCallback(),this}setFromUnitVectors(t,s){let e=t.dot(s)+1;return e<Number.EPSILON?(e=0,Math.abs(t.x)>Math.abs(t.z)?(this._x=-t.y,this._y=t.x,this._z=0,this._w=e):(this._x=0,this._y=-t.z,this._z=t.y,this._w=e)):(this._x=t.y*s.z-t.z*s.y,this._y=t.z*s.x-t.x*s.z,this._z=t.x*s.y-t.y*s.x,this._w=e),this.normalize()}angleTo(t){return 2*Math.acos(Math.abs(w(this.dot(t),-1,1)))}rotateTowards(t,s){const e=this.angleTo(t);if(e===0)return this;const i=Math.min(1,s/e);return this.slerp(t,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(t){return this._x*t._x+this._y*t._y+this._z*t._z+this._w*t._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let t=this.length();return t===0?(this._x=0,this._y=0,this._z=0,this._w=1):(t=1/t,this._x=this._x*t,this._y=this._y*t,this._z=this._z*t,this._w=this._w*t),this._onChangeCallback(),this}multiply(t){return this.multiplyQuaternions(this,t)}premultiply(t){return this.multiplyQuaternions(t,this)}multiplyQuaternions(t,s){const e=t._x,i=t._y,h=t._z,n=t._w,o=s._x,r=s._y,a=s._z,l=s._w;return this._x=e*l+n*o+i*a-h*r,this._y=i*l+n*r+h*o-e*a,this._z=h*l+n*a+e*r-i*o,this._w=n*l-e*o-i*r-h*a,this._onChangeCallback(),this}slerp(t,s){if(s===0)return this;if(s===1)return this.copy(t);const e=this._x,i=this._y,h=this._z,n=this._w;let o=n*t._w+e*t._x+i*t._y+h*t._z;if(o<0?(this._w=-t._w,this._x=-t._x,this._y=-t._y,this._z=-t._z,o=-o):this.copy(t),o>=1)return this._w=n,this._x=e,this._y=i,this._z=h,this;const r=1-o*o;if(r<=Number.EPSILON){const c=1-s;return this._w=c*n+s*this._w,this._x=c*e+s*this._x,this._y=c*i+s*this._y,this._z=c*h+s*this._z,this.normalize(),this}const a=Math.sqrt(r),l=Math.atan2(a,o),u=Math.sin((1-s)*l)/a,y=Math.sin(s*l)/a;return this._w=n*u+this._w*y,this._x=e*u+this._x*y,this._y=i*u+this._y*y,this._z=h*u+this._z*y,this._onChangeCallback(),this}slerpQuaternions(t,s,e){return this.copy(t).slerp(s,e)}random(){const t=2*Math.PI*Math.random(),s=2*Math.PI*Math.random(),e=Math.random(),i=Math.sqrt(1-e),h=Math.sqrt(e);return this.set(i*Math.sin(t),i*Math.cos(t),h*Math.sin(s),h*Math.cos(s))}equals(t){return t._x===this._x&&t._y===this._y&&t._z===this._z&&t._w===this._w}fromArray(t,s=0){return this._x=t[s],this._y=t[s+1],this._z=t[s+2],this._w=t[s+3],this._onChangeCallback(),this}toArray(t=[],s=0){return t[s]=this._x,t[s+1]=this._y,t[s+2]=this._z,t[s+3]=this._w,t}fromBufferAttribute(t,s){return this._x=t.getX(s),this._y=t.getY(s),this._z=t.getZ(s),this._w=t.getW(s),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(t){return this._onChangeCallback=t,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class S{constructor(t=0,s=0,e=0){S.prototype.isVector3=!0,this.x=t,this.y=s,this.z=e}set(t,s,e){return e===void 0&&(e=this.z),this.x=t,this.y=s,this.z=e,this}setScalar(t){return this.x=t,this.y=t,this.z=t,this}setX(t){return this.x=t,this}setY(t){return this.y=t,this}setZ(t){return this.z=t,this}setComponent(t,s){switch(t){case 0:this.x=s;break;case 1:this.y=s;break;case 2:this.z=s;break;default:throw new Error("index is out of range: "+t)}return this}getComponent(t){switch(t){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+t)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this}add(t){return this.x+=t.x,this.y+=t.y,this.z+=t.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}addVectors(t,s){return this.x=t.x+s.x,this.y=t.y+s.y,this.z=t.z+s.z,this}addScaledVector(t,s){return this.x+=t.x*s,this.y+=t.y*s,this.z+=t.z*s,this}sub(t){return this.x-=t.x,this.y-=t.y,this.z-=t.z,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}subVectors(t,s){return this.x=t.x-s.x,this.y=t.y-s.y,this.z=t.z-s.z,this}multiply(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}multiplyVectors(t,s){return this.x=t.x*s.x,this.y=t.y*s.y,this.z=t.z*s.z,this}applyEuler(t){return this.applyQuaternion(K.setFromEuler(t))}applyAxisAngle(t,s){return this.applyQuaternion(K.setFromAxisAngle(t,s))}applyMatrix3(t){const s=this.x,e=this.y,i=this.z,h=t.elements;return this.x=h[0]*s+h[3]*e+h[6]*i,this.y=h[1]*s+h[4]*e+h[7]*i,this.z=h[2]*s+h[5]*e+h[8]*i,this}applyNormalMatrix(t){return this.applyMatrix3(t).normalize()}applyMatrix4(t){const s=this.x,e=this.y,i=this.z,h=t.elements,n=1/(h[3]*s+h[7]*e+h[11]*i+h[15]);return this.x=(h[0]*s+h[4]*e+h[8]*i+h[12])*n,this.y=(h[1]*s+h[5]*e+h[9]*i+h[13])*n,this.z=(h[2]*s+h[6]*e+h[10]*i+h[14])*n,this}applyQuaternion(t){const s=this.x,e=this.y,i=this.z,h=t.x,n=t.y,o=t.z,r=t.w,a=2*(n*i-o*e),l=2*(o*s-h*i),u=2*(h*e-n*s);return this.x=s+r*a+n*u-o*l,this.y=e+r*l+o*a-h*u,this.z=i+r*u+h*l-n*a,this}project(t){return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix)}unproject(t){return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld)}transformDirection(t){const s=this.x,e=this.y,i=this.z,h=t.elements;return this.x=h[0]*s+h[4]*e+h[8]*i,this.y=h[1]*s+h[5]*e+h[9]*i,this.z=h[2]*s+h[6]*e+h[10]*i,this.normalize()}divide(t){return this.x/=t.x,this.y/=t.y,this.z/=t.z,this}divideScalar(t){return this.multiplyScalar(1/t)}min(t){return this.x=Math.min(this.x,t.x),this.y=Math.min(this.y,t.y),this.z=Math.min(this.z,t.z),this}max(t){return this.x=Math.max(this.x,t.x),this.y=Math.max(this.y,t.y),this.z=Math.max(this.z,t.z),this}clamp(t,s){return this.x=w(this.x,t.x,s.x),this.y=w(this.y,t.y,s.y),this.z=w(this.z,t.z,s.z),this}clampScalar(t,s){return this.x=w(this.x,t,s),this.y=w(this.y,t,s),this.z=w(this.z,t,s),this}clampLength(t,s){const e=this.length();return this.divideScalar(e||1).multiplyScalar(w(e,t,s))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(t){return this.x*t.x+this.y*t.y+this.z*t.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(t){return this.normalize().multiplyScalar(t)}lerp(t,s){return this.x+=(t.x-this.x)*s,this.y+=(t.y-this.y)*s,this.z+=(t.z-this.z)*s,this}lerpVectors(t,s,e){return this.x=t.x+(s.x-t.x)*e,this.y=t.y+(s.y-t.y)*e,this.z=t.z+(s.z-t.z)*e,this}cross(t){return this.crossVectors(this,t)}crossVectors(t,s){const e=t.x,i=t.y,h=t.z,n=s.x,o=s.y,r=s.z;return this.x=i*r-h*o,this.y=h*n-e*r,this.z=e*o-i*n,this}projectOnVector(t){const s=t.lengthSq();if(s===0)return this.set(0,0,0);const e=t.dot(this)/s;return this.copy(t).multiplyScalar(e)}projectOnPlane(t){return G.copy(this).projectOnVector(t),this.sub(G)}reflect(t){return this.sub(G.copy(t).multiplyScalar(2*this.dot(t)))}angleTo(t){const s=Math.sqrt(this.lengthSq()*t.lengthSq());if(s===0)return Math.PI/2;const e=this.dot(t)/s;return Math.acos(w(e,-1,1))}distanceTo(t){return Math.sqrt(this.distanceToSquared(t))}distanceToSquared(t){const s=this.x-t.x,e=this.y-t.y,i=this.z-t.z;return s*s+e*e+i*i}manhattanDistanceTo(t){return Math.abs(this.x-t.x)+Math.abs(this.y-t.y)+Math.abs(this.z-t.z)}setFromSpherical(t){return this.setFromSphericalCoords(t.radius,t.phi,t.theta)}setFromSphericalCoords(t,s,e){const i=Math.sin(s)*t;return this.x=i*Math.sin(e),this.y=Math.cos(s)*t,this.z=i*Math.cos(e),this}setFromCylindrical(t){return this.setFromCylindricalCoords(t.radius,t.theta,t.y)}setFromCylindricalCoords(t,s,e){return this.x=t*Math.sin(s),this.y=e,this.z=t*Math.cos(s),this}setFromMatrixPosition(t){const s=t.elements;return this.x=s[12],this.y=s[13],this.z=s[14],this}setFromMatrixScale(t){const s=this.setFromMatrixColumn(t,0).length(),e=this.setFromMatrixColumn(t,1).length(),i=this.setFromMatrixColumn(t,2).length();return this.x=s,this.y=e,this.z=i,this}setFromMatrixColumn(t,s){return this.fromArray(t.elements,s*4)}setFromMatrix3Column(t,s){return this.fromArray(t.elements,s*3)}setFromEuler(t){return this.x=t._x,this.y=t._y,this.z=t._z,this}setFromColor(t){return this.x=t.r,this.y=t.g,this.z=t.b,this}equals(t){return t.x===this.x&&t.y===this.y&&t.z===this.z}fromArray(t,s=0){return this.x=t[s],this.y=t[s+1],this.z=t[s+2],this}toArray(t=[],s=0){return t[s]=this.x,t[s+1]=this.y,t[s+2]=this.z,t}fromBufferAttribute(t,s){return this.x=t.getX(s),this.y=t.getY(s),this.z=t.getZ(s),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const t=Math.random()*Math.PI*2,s=Math.random()*2-1,e=Math.sqrt(1-s*s);return this.x=e*Math.cos(t),this.y=s,this.z=e*Math.sin(t),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const G=new S,K=new v;class R{constructor(t,s,e,i,h,n,o,r,a,l,u,y,c,x,m,_){R.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],t!==void 0&&this.set(t,s,e,i,h,n,o,r,a,l,u,y,c,x,m,_)}set(t,s,e,i,h,n,o,r,a,l,u,y,c,x,m,_){const g=this.elements;return g[0]=t,g[4]=s,g[8]=e,g[12]=i,g[1]=h,g[5]=n,g[9]=o,g[13]=r,g[2]=a,g[6]=l,g[10]=u,g[14]=y,g[3]=c,g[7]=x,g[11]=m,g[15]=_,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new R().fromArray(this.elements)}copy(t){const s=this.elements,e=t.elements;return s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],s[4]=e[4],s[5]=e[5],s[6]=e[6],s[7]=e[7],s[8]=e[8],s[9]=e[9],s[10]=e[10],s[11]=e[11],s[12]=e[12],s[13]=e[13],s[14]=e[14],s[15]=e[15],this}copyPosition(t){const s=this.elements,e=t.elements;return s[12]=e[12],s[13]=e[13],s[14]=e[14],this}setFromMatrix3(t){const s=t.elements;return this.set(s[0],s[3],s[6],0,s[1],s[4],s[7],0,s[2],s[5],s[8],0,0,0,0,1),this}extractBasis(t,s,e){return t.setFromMatrixColumn(this,0),s.setFromMatrixColumn(this,1),e.setFromMatrixColumn(this,2),this}makeBasis(t,s,e){return this.set(t.x,s.x,e.x,0,t.y,s.y,e.y,0,t.z,s.z,e.z,0,0,0,0,1),this}extractRotation(t){const s=this.elements,e=t.elements,i=1/B.setFromMatrixColumn(t,0).length(),h=1/B.setFromMatrixColumn(t,1).length(),n=1/B.setFromMatrixColumn(t,2).length();return s[0]=e[0]*i,s[1]=e[1]*i,s[2]=e[2]*i,s[3]=0,s[4]=e[4]*h,s[5]=e[5]*h,s[6]=e[6]*h,s[7]=0,s[8]=e[8]*n,s[9]=e[9]*n,s[10]=e[10]*n,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromEuler(t){const s=this.elements,e=t.x,i=t.y,h=t.z,n=Math.cos(e),o=Math.sin(e),r=Math.cos(i),a=Math.sin(i),l=Math.cos(h),u=Math.sin(h);if(t.order==="XYZ"){const y=n*l,c=n*u,x=o*l,m=o*u;s[0]=r*l,s[4]=-r*u,s[8]=a,s[1]=c+x*a,s[5]=y-m*a,s[9]=-o*r,s[2]=m-y*a,s[6]=x+c*a,s[10]=n*r}else if(t.order==="YXZ"){const y=r*l,c=r*u,x=a*l,m=a*u;s[0]=y+m*o,s[4]=x*o-c,s[8]=n*a,s[1]=n*u,s[5]=n*l,s[9]=-o,s[2]=c*o-x,s[6]=m+y*o,s[10]=n*r}else if(t.order==="ZXY"){const y=r*l,c=r*u,x=a*l,m=a*u;s[0]=y-m*o,s[4]=-n*u,s[8]=x+c*o,s[1]=c+x*o,s[5]=n*l,s[9]=m-y*o,s[2]=-n*a,s[6]=o,s[10]=n*r}else if(t.order==="ZYX"){const y=n*l,c=n*u,x=o*l,m=o*u;s[0]=r*l,s[4]=x*a-c,s[8]=y*a+m,s[1]=r*u,s[5]=m*a+y,s[9]=c*a-x,s[2]=-a,s[6]=o*r,s[10]=n*r}else if(t.order==="YZX"){const y=n*r,c=n*a,x=o*r,m=o*a;s[0]=r*l,s[4]=m-y*u,s[8]=x*u+c,s[1]=u,s[5]=n*l,s[9]=-o*l,s[2]=-a*l,s[6]=c*u+x,s[10]=y-m*u}else if(t.order==="XZY"){const y=n*r,c=n*a,x=o*r,m=o*a;s[0]=r*l,s[4]=-u,s[8]=a*l,s[1]=y*u+m,s[5]=n*l,s[9]=c*u-x,s[2]=x*u-c,s[6]=o*l,s[10]=m*u+y}return s[3]=0,s[7]=0,s[11]=0,s[12]=0,s[13]=0,s[14]=0,s[15]=1,this}makeRotationFromQuaternion(t){return this.compose(tt,t,st)}lookAt(t,s,e){const i=this.elements;return A.subVectors(t,s),A.lengthSq()===0&&(A.z=1),A.normalize(),P.crossVectors(e,A),P.lengthSq()===0&&(Math.abs(e.z)===1?A.x+=1e-4:A.z+=1e-4,A.normalize(),P.crossVectors(e,A)),P.normalize(),$.crossVectors(A,P),i[0]=P.x,i[4]=$.x,i[8]=A.x,i[1]=P.y,i[5]=$.y,i[9]=A.y,i[2]=P.z,i[6]=$.z,i[10]=A.z,this}multiply(t){return this.multiplyMatrices(this,t)}premultiply(t){return this.multiplyMatrices(t,this)}multiplyMatrices(t,s){const e=t.elements,i=s.elements,h=this.elements,n=e[0],o=e[4],r=e[8],a=e[12],l=e[1],u=e[5],y=e[9],c=e[13],x=e[2],m=e[6],_=e[10],g=e[14],b=e[3],f=e[7],M=e[11],p=e[15],k=i[0],z=i[4],L=i[8],q=i[12],N=i[1],E=i[5],I=i[9],F=i[13],X=i[2],Z=i[6],H=i[10],Y=i[14],D=i[3],W=i[7],U=i[11],Q=i[15];return h[0]=n*k+o*N+r*X+a*D,h[4]=n*z+o*E+r*Z+a*W,h[8]=n*L+o*I+r*H+a*U,h[12]=n*q+o*F+r*Y+a*Q,h[1]=l*k+u*N+y*X+c*D,h[5]=l*z+u*E+y*Z+c*W,h[9]=l*L+u*I+y*H+c*U,h[13]=l*q+u*F+y*Y+c*Q,h[2]=x*k+m*N+_*X+g*D,h[6]=x*z+m*E+_*Z+g*W,h[10]=x*L+m*I+_*H+g*U,h[14]=x*q+m*F+_*Y+g*Q,h[3]=b*k+f*N+M*X+p*D,h[7]=b*z+f*E+M*Z+p*W,h[11]=b*L+f*I+M*H+p*U,h[15]=b*q+f*F+M*Y+p*Q,this}multiplyScalar(t){const s=this.elements;return s[0]*=t,s[4]*=t,s[8]*=t,s[12]*=t,s[1]*=t,s[5]*=t,s[9]*=t,s[13]*=t,s[2]*=t,s[6]*=t,s[10]*=t,s[14]*=t,s[3]*=t,s[7]*=t,s[11]*=t,s[15]*=t,this}determinant(){const t=this.elements,s=t[0],e=t[4],i=t[8],h=t[12],n=t[1],o=t[5],r=t[9],a=t[13],l=t[2],u=t[6],y=t[10],c=t[14],x=t[3],m=t[7],_=t[11],g=t[15];return x*(+h*r*u-i*a*u-h*o*y+e*a*y+i*o*c-e*r*c)+m*(+s*r*c-s*a*y+h*n*y-i*n*c+i*a*l-h*r*l)+_*(+s*a*u-s*o*c-h*n*u+e*n*c+h*o*l-e*a*l)+g*(-i*o*l-s*r*u+s*o*y+i*n*u-e*n*y+e*r*l)}transpose(){const t=this.elements;let s;return s=t[1],t[1]=t[4],t[4]=s,s=t[2],t[2]=t[8],t[8]=s,s=t[6],t[6]=t[9],t[9]=s,s=t[3],t[3]=t[12],t[12]=s,s=t[7],t[7]=t[13],t[13]=s,s=t[11],t[11]=t[14],t[14]=s,this}setPosition(t,s,e){const i=this.elements;return t.isVector3?(i[12]=t.x,i[13]=t.y,i[14]=t.z):(i[12]=t,i[13]=s,i[14]=e),this}invert(){const t=this.elements,s=t[0],e=t[1],i=t[2],h=t[3],n=t[4],o=t[5],r=t[6],a=t[7],l=t[8],u=t[9],y=t[10],c=t[11],x=t[12],m=t[13],_=t[14],g=t[15],b=u*_*a-m*y*a+m*r*c-o*_*c-u*r*g+o*y*g,f=x*y*a-l*_*a-x*r*c+n*_*c+l*r*g-n*y*g,M=l*m*a-x*u*a+x*o*c-n*m*c-l*o*g+n*u*g,p=x*u*r-l*m*r-x*o*y+n*m*y+l*o*_-n*u*_,k=s*b+e*f+i*M+h*p;if(k===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const z=1/k;return t[0]=b*z,t[1]=(m*y*h-u*_*h-m*i*c+e*_*c+u*i*g-e*y*g)*z,t[2]=(o*_*h-m*r*h+m*i*a-e*_*a-o*i*g+e*r*g)*z,t[3]=(u*r*h-o*y*h-u*i*a+e*y*a+o*i*c-e*r*c)*z,t[4]=f*z,t[5]=(l*_*h-x*y*h+x*i*c-s*_*c-l*i*g+s*y*g)*z,t[6]=(x*r*h-n*_*h-x*i*a+s*_*a+n*i*g-s*r*g)*z,t[7]=(n*y*h-l*r*h+l*i*a-s*y*a-n*i*c+s*r*c)*z,t[8]=M*z,t[9]=(x*u*h-l*m*h-x*e*c+s*m*c+l*e*g-s*u*g)*z,t[10]=(n*m*h-x*o*h+x*e*a-s*m*a-n*e*g+s*o*g)*z,t[11]=(l*o*h-n*u*h-l*e*a+s*u*a+n*e*c-s*o*c)*z,t[12]=p*z,t[13]=(l*m*i-x*u*i+x*e*y-s*m*y-l*e*_+s*u*_)*z,t[14]=(x*o*i-n*m*i-x*e*r+s*m*r+n*e*_-s*o*_)*z,t[15]=(n*u*i-l*o*i+l*e*r-s*u*r-n*e*y+s*o*y)*z,this}scale(t){const s=this.elements,e=t.x,i=t.y,h=t.z;return s[0]*=e,s[4]*=i,s[8]*=h,s[1]*=e,s[5]*=i,s[9]*=h,s[2]*=e,s[6]*=i,s[10]*=h,s[3]*=e,s[7]*=i,s[11]*=h,this}getMaxScaleOnAxis(){const t=this.elements,s=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],e=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(s,e,i))}makeTranslation(t,s,e){return t.isVector3?this.set(1,0,0,t.x,0,1,0,t.y,0,0,1,t.z,0,0,0,1):this.set(1,0,0,t,0,1,0,s,0,0,1,e,0,0,0,1),this}makeRotationX(t){const s=Math.cos(t),e=Math.sin(t);return this.set(1,0,0,0,0,s,-e,0,0,e,s,0,0,0,0,1),this}makeRotationY(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,0,e,0,0,1,0,0,-e,0,s,0,0,0,0,1),this}makeRotationZ(t){const s=Math.cos(t),e=Math.sin(t);return this.set(s,-e,0,0,e,s,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(t,s){const e=Math.cos(s),i=Math.sin(s),h=1-e,n=t.x,o=t.y,r=t.z,a=h*n,l=h*o;return this.set(a*n+e,a*o-i*r,a*r+i*o,0,a*o+i*r,l*o+e,l*r-i*n,0,a*r-i*o,l*r+i*n,h*r*r+e,0,0,0,0,1),this}makeScale(t,s,e){return this.set(t,0,0,0,0,s,0,0,0,0,e,0,0,0,0,1),this}makeShear(t,s,e,i,h,n){return this.set(1,e,h,0,t,1,n,0,s,i,1,0,0,0,0,1),this}compose(t,s,e){const i=this.elements,h=s._x,n=s._y,o=s._z,r=s._w,a=h+h,l=n+n,u=o+o,y=h*a,c=h*l,x=h*u,m=n*l,_=n*u,g=o*u,b=r*a,f=r*l,M=r*u,p=e.x,k=e.y,z=e.z;return i[0]=(1-(m+g))*p,i[1]=(c+M)*p,i[2]=(x-f)*p,i[3]=0,i[4]=(c-M)*k,i[5]=(1-(y+g))*k,i[6]=(_+b)*k,i[7]=0,i[8]=(x+f)*z,i[9]=(_-b)*z,i[10]=(1-(y+m))*z,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}decompose(t,s,e){const i=this.elements;let h=B.set(i[0],i[1],i[2]).length();const n=B.set(i[4],i[5],i[6]).length(),o=B.set(i[8],i[9],i[10]).length();this.determinant()<0&&(h=-h),t.x=i[12],t.y=i[13],t.z=i[14],T.copy(this);const a=1/h,l=1/n,u=1/o;return T.elements[0]*=a,T.elements[1]*=a,T.elements[2]*=a,T.elements[4]*=l,T.elements[5]*=l,T.elements[6]*=l,T.elements[8]*=u,T.elements[9]*=u,T.elements[10]*=u,s.setFromRotationMatrix(T),e.x=h,e.y=n,e.z=o,this}makePerspective(t,s,e,i,h,n,o=2e3){const r=this.elements,a=2*h/(s-t),l=2*h/(e-i),u=(s+t)/(s-t),y=(e+i)/(e-i);let c,x;if(o===2e3)c=-(n+h)/(n-h),x=-2*n*h/(n-h);else if(o===2001)c=-n/(n-h),x=-n*h/(n-h);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return r[0]=a,r[4]=0,r[8]=u,r[12]=0,r[1]=0,r[5]=l,r[9]=y,r[13]=0,r[2]=0,r[6]=0,r[10]=c,r[14]=x,r[3]=0,r[7]=0,r[11]=-1,r[15]=0,this}makeOrthographic(t,s,e,i,h,n,o=2e3){const r=this.elements,a=1/(s-t),l=1/(e-i),u=1/(n-h),y=(s+t)*a,c=(e+i)*l;let x,m;if(o===2e3)x=(n+h)*u,m=-2*u;else if(o===2001)x=h*u,m=-1*u;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return r[0]=2*a,r[4]=0,r[8]=0,r[12]=-y,r[1]=0,r[5]=2*l,r[9]=0,r[13]=-c,r[2]=0,r[6]=0,r[10]=m,r[14]=-x,r[3]=0,r[7]=0,r[11]=0,r[15]=1,this}equals(t){const s=this.elements,e=t.elements;for(let i=0;i<16;i++)if(s[i]!==e[i])return!1;return!0}fromArray(t,s=0){for(let e=0;e<16;e++)this.elements[e]=t[e+s];return this}toArray(t=[],s=0){const e=this.elements;return t[s]=e[0],t[s+1]=e[1],t[s+2]=e[2],t[s+3]=e[3],t[s+4]=e[4],t[s+5]=e[5],t[s+6]=e[6],t[s+7]=e[7],t[s+8]=e[8],t[s+9]=e[9],t[s+10]=e[10],t[s+11]=e[11],t[s+12]=e[12],t[s+13]=e[13],t[s+14]=e[14],t[s+15]=e[15],t}}const B=new S,T=new R,tt=new S(0,0,0),st=new S(1,1,1),P=new S,$=new S,A=new S;class et{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.")}getPointAt(t,s){const e=this.getUtoTmapping(t);return this.getPoint(e,s)}getPoints(t=5){const s=[];for(let e=0;e<=t;e++)s.push(this.getPoint(e/t));return s}getSpacedPoints(t=5){const s=[];for(let e=0;e<=t;e++)s.push(this.getPointAt(e/t));return s}getLength(){const t=this.getLengths();return t[t.length-1]}getLengths(t=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===t+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const s=[];let e,i=this.getPoint(0),h=0;s.push(0);for(let n=1;n<=t;n++)e=this.getPoint(n/t),h+=e.distanceTo(i),s.push(h),i=e;return this.cacheArcLengths=s,s}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(t,s=null){const e=this.getLengths();let i=0;const h=e.length;let n;s?n=s:n=t*e[h-1];let o=0,r=h-1,a;for(;o<=r;)if(i=Math.floor(o+(r-o)/2),a=e[i]-n,a<0)o=i+1;else if(a>0)r=i-1;else{r=i;break}if(i=r,e[i]===n)return i/(h-1);const l=e[i],y=e[i+1]-l,c=(n-l)/y;return(i+c)/(h-1)}getTangent(t,s){let i=t-1e-4,h=t+1e-4;i<0&&(i=0),h>1&&(h=1);const n=this.getPoint(i),o=this.getPoint(h),r=s||(n.isVector2?new d:new S);return r.copy(o).sub(n).normalize(),r}getTangentAt(t,s){const e=this.getUtoTmapping(t);return this.getTangent(e,s)}computeFrenetFrames(t,s=!1){const e=new S,i=[],h=[],n=[],o=new S,r=new R;for(let c=0;c<=t;c++){const x=c/t;i[c]=this.getTangentAt(x,new S)}h[0]=new S,n[0]=new S;let a=Number.MAX_VALUE;const l=Math.abs(i[0].x),u=Math.abs(i[0].y),y=Math.abs(i[0].z);l<=a&&(a=l,e.set(1,0,0)),u<=a&&(a=u,e.set(0,1,0)),y<=a&&e.set(0,0,1),o.crossVectors(i[0],e).normalize(),h[0].crossVectors(i[0],o),n[0].crossVectors(i[0],h[0]);for(let c=1;c<=t;c++){if(h[c]=h[c-1].clone(),n[c]=n[c-1].clone(),o.crossVectors(i[c-1],i[c]),o.length()>Number.EPSILON){o.normalize();const x=Math.acos(w(i[c-1].dot(i[c]),-1,1));h[c].applyMatrix4(r.makeRotationAxis(o,x))}n[c].crossVectors(i[c],h[c])}if(s===!0){let c=Math.acos(w(h[0].dot(h[t]),-1,1));c/=t,i[0].dot(o.crossVectors(h[0],h[t]))>0&&(c=-c);for(let x=1;x<=t;x++)h[x].applyMatrix4(r.makeRotationAxis(i[x],c*x)),n[x].crossVectors(i[x],h[x])}return{tangents:i,normals:h,binormals:n}}clone(){return new this.constructor().copy(this)}copy(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}toJSON(){const t={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return t.arcLengthDivisions=this.arcLengthDivisions,t.type=this.type,t}fromJSON(t){return this.arcLengthDivisions=t.arcLengthDivisions,this}}function O(C,t,s,e,i){const h=(e-t)*.5,n=(i-s)*.5,o=C*C,r=C*o;return(2*s-2*e+h+n)*r+(-3*s+3*e-2*h-n)*o+h*C+s}class j extends et{constructor(t=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=t}getPoint(t,s=new d){const e=s,i=this.points,h=(i.length-1)*t,n=Math.floor(h),o=h-n,r=i[n===0?n:n-1],a=i[n],l=i[n>i.length-2?i.length-1:n+1],u=i[n>i.length-3?i.length-1:n+2];return e.set(O(o,r.x,a.x,l.x,u.x),O(o,r.y,a.y,l.y,u.y)),e}copy(t){super.copy(t),this.points=[];for(let s=0,e=t.points.length;s<e;s++){const i=t.points[s];this.points.push(i.clone())}return this}toJSON(){const t=super.toJSON();t.points=[];for(let s=0,e=this.points.length;s<e;s++){const i=this.points[s];t.points.push(i.toArray())}return t}fromJSON(t){super.fromJSON(t),this.points=[];for(let s=0,e=t.points.length;s<e;s++){const i=t.points[s];this.points.push(new d().fromArray(i))}return this}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:J}})),typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=J);class it{constructor(){this.blockTable=null,this.worldSeed=69420,this._globalPerm=null}initialize(t){this.worldSeed=t.worldSeed,this.blockTable=t.blockTable,this.amplitude=t.amplitude,this.chunkSize=t.chunkSize,this.chunkHeight=t.chunkHeight,this.TRANSPARENT_BLOCKS=new Set(t.transparentBlocks)}generateChunk(t,s){const e=new ht(this,t,s);return e.generateTerrain(),e.createTrees(),{chunkId:`${t},${s}`,chunkX:t,chunkZ:s,grid:Array.from(e.grid.entries()),waterBlocks:e.waterBlocks,size:e.size,height:e.height,lastAccessed:e.lastAccessed}}findSpawnLocation(t,s=2){const e=this.chunks.get(t);return e?e.findSpawnLocation(s):null}generatePermTable(t){const s=new Array(512);let e=t;const i=()=>(e=(e*1664525+1013904223)%4294967296,e/4294967296);for(let h=0;h<256;h++)s[h]=Math.floor(i()*256),s[h+256]=s[h];return s}}class ht{constructor(t,s,e){this.worker=t,this.chunkX=s,this.chunkZ=e,this.size=t.chunkSize,this.height=t.chunkHeight,this.grid=new Map,this.waterBlocks=[],this.lastAccessed=Date.now(),this.waterLevel=Math.floor(this.worker.amplitude/4),this.TRANSPARENT_BLOCKS=new Set([-1,4,5]),this.CSpline=new j([new d(0,0),new d(.75,.25),new d(1,1)]),this.MVSpline=new j([new d(0,.1),new d(.1,.2),new d(.12,.4),new d(.4,.4),new d(.41,1),new d(.6,.6),new d(1,.1)]),this.PVSpline=new j([new d(0,0),new d(.43,.1),new d(.82,.4),new d(.9,.9),new d(.93,1),new d(1,.7)])}generateTerrain(){const t=new Map,s=2,e=1.5;for(let h=-1;h<=this.size;h++)for(let n=-1;n<=this.size;n++){const o=h+this.chunkX*this.size,r=n+this.chunkZ*this.size;t.set(`${h},${n}`,this.generateHeightAt(o,r))}const i=[];for(let h=0;h<this.size;h++)for(let n=0;n<this.size;n++){const o=t.get(`${h},${n}`),r=t.get(`${h+1},${n}`)||o,a=t.get(`${h},${n+1}`)||o,l=t.get(`${h-1},${n}`)||o,u=t.get(`${h},${n-1}`)||o,y=(r-l)/2,c=(a-u)/2,x=(y+c)/2;for(let m=0;m<Math.max(this.waterLevel,o);m++){let _;m>o?_=5:m<o-4?_=1:m-this.waterLevel<=1?_=7:m<o-1?x>e?_=1:_=0:x<e?_=2:x<s?_=0:_=1,i.push([`${h} ${m} ${n}`,_])}}this.grid=new Map(i)}generateHeightAt(t,s){let i=this.getNoise(1,.002,.5,t,s),h=this.getNoise(2,.002*2,.5,t,s),n=this.getNoise(3,.02,.5,t,s);const o=this.CSpline.getPoint(i).y,r=this.MVSpline.getPoint(h).y,a=this.PVSpline.getPoint(n).y,y=o+2*r*o+a*r*o,c=this.worker.amplitude*(y/2);return Math.min(this.worker.chunkHeight-8,c)}getNoise(t,s,e,i,h){let n=0,o=s,r=0,a=1;for(let l=0;l<t;l++){const u=this.perlin2d(i*o,h*o);n+=u*a,r+=a,o*=2,a*=e}return(n/r+1)/2}perlin2d(t,s){this.worker._globalPerm||(this.worker._globalPerm=this.worker.generatePermTable(this.worker.worldSeed)),this._perm=this.worker._globalPerm;const e=[[1,1],[-1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]],i=(L,q,N)=>{const E=e[L&7];return E[0]*q+E[1]*N},h=L=>L*L*L*(L*(L*6-15)+10),n=Math.floor(t)&255,o=Math.floor(s)&255,r=t-Math.floor(t),a=s-Math.floor(s),l=h(r),u=h(a),y=this._perm[n]+o,c=this._perm[n+1]+o,x=this._perm[y],m=this._perm[y+1],_=this._perm[c],g=this._perm[c+1],b=i(this._perm[x],r,a),f=i(this._perm[_],r-1,a),M=i(this._perm[m],r,a-1),p=i(this._perm[g],r-1,a-1),k=b+l*(f-b),z=M+l*(p-M);return k+u*(z-k)}createTrees(){for(let s=2;s<this.size-2;s++)for(let e=2;e<this.size-2;e++){const i=this.getHighestBlock(s,e);if(i===-1||i<=this.waterLevel)continue;this.getBlock(s,i,e)===2&&Math.random()<.01&&this.buildTree(s,i,e)}}buildTree(t,s,e){const i=4+Math.floor(Math.random()*4);for(let o=1;o<=i&&!(s+o>=this.height);o++)this.setBlock(t,s+o,e,3);const h=Math.max(2,i-3),n=i+1;for(let o=h;o<=n;o++){let r=2;o===n&&(r=1);for(let a=-r;a<=r;a++)for(let l=-r;l<=r;l++){if(Math.abs(a)===2&&Math.abs(l)===2||a===0&&l===0&&o!==n)continue;const u=t+a,y=e+l;u>=0&&u<this.size&&y>=0&&y<this.size&&s+o<this.height&&this.getBlock(u,s+o,y)===-1&&this.setBlock(u,s+o,y,4)}}}buildLakes(){for(let t=0;t<this.size;t++)for(let s=0;s<this.size;s++)for(let e=0;e<this.height;e++){const i=this.getBlock(t,e,s);i===5&&this.getBlock(t,e+1,s),e>=3&&e<=this.waterLevel&&i===-1&&this.setBlock(t,e,s,5)}}setBlock(t,s,e,i){this.lastAccessed=Date.now();const h=`${t} ${s} ${e}`;i===-1||i===null?this.grid.delete(h):(this.grid.set(h,i),this.grid.get(`${t} ${s-1} ${e}`)===2&&!this.TRANSPARENT_BLOCKS.has(i)&&this.grid.set(`${t} ${s-1} ${e}`,0))}getBlock(t,s,e){this.lastAccessed=Date.now();const i=this.grid.get(`${t} ${s} ${e}`);return i===void 0?-1:i}getHighestBlock(t,s){for(let e=this.height-1;e>=0;e--)if(this.getBlock(t,e,s)!==-1)return e;return-1}findSpawnLocation(t=2){for(let e=0;e<100;e++){const i=Math.floor(Math.random()*(this.size-2))+1,h=Math.floor(Math.random()*(this.size-2))+1,n=this.getHighestBlock(i,h);if(n===-1)continue;const o=this.getBlock(i,n,h);if(o!==-1&&!this.worker.TRANSPARENT_BLOCKS.has(o)){let r=!0;for(let a=1;a<=t;a++)if(this.getBlock(i,n+a,h)!==-1){r=!1;break}if(r)return[i+this.chunkX*this.size+.5,n+t/2,h+this.chunkZ*this.size+.5]}}return[this.chunkX*this.size+this.size/2,this.height/2,this.chunkZ*this.size+this.size/2]}}const V=new it;self.onmessage=function(C){const{type:t,chunkX:s,chunkZ:e,params:i,chunkId:h,x:n,y:o,z:r,blockType:a,objHeight:l,frameno:u}=C.data;try{switch(t){case"initialize":V.initialize(i),self.postMessage({type:"initialized",frameno:u,success:!0});break;case"generateChunk":const y=V.generateChunk(s,e);y.frameno=u,self.postMessage({type:"chunkGenerated",data:y});break;case"updateBlock":const c=V.updateBlock(h,n,o,r,a,C.data.updateWaterMesh);c.frameno=u,c&&self.postMessage({type:"chunkUpdated",data:c});break;case"getBlock":const x=V.getBlock(h,n,o,r);self.postMessage({type:"blockResult",chunkId:h,blockId:x,frameno:u});break;case"findSpawn":const m=V.findSpawnLocation(h,l);self.postMessage({type:"spawnFound",chunkId:h,location:m,frameno:u});break;default:throw new Error(`Unknown message type: ${t}`)}}catch(y){self.postMessage({type:"error",chunkId:h,error:y.message,stack:y.stack,frameno:u})}}})();
